cmake_minimum_required(VERSION 2.4)

if(COMMAND cmake_policy)
	cmake_policy(SET CMP0003 NEW)
endif(COMMAND cmake_policy)


project(libroboint C)

# tgz
SET(CPACK_PACKAGE_DESCRIPTION_SUMMARY "libroboint")
SET(CPACK_PACKAGE_VENDOR "Erik Andresen")
SET(CPACK_PACKAGE_DESCRIPTION_FILE "${CMAKE_CURRENT_SOURCE_DIR}/README")
SET(CPACK_PACKAGE_VERSION_MAJOR "0")
SET(CPACK_PACKAGE_VERSION_MINOR "5")
SET(CPACK_PACKAGE_VERSION_PATCH "2")
SET(CPACK_PACKAGE_INSTALL_DIRECTORY "libroboint ${CPACK_VERSION_MAJOR}.${CPACK_VERSION_MINOR}")
SET(CPACK_SOURCE_STRIP_FILES "")
SET(CPACK_GENERATOR "TGZ")
SET(CPACK_SOURCE_GENERATOR "TGZ")
SET(CPACK_SOURCE_IGNORE_FILES "CMakeCache.txt;CMakeCache.txt;cmake_install.cmake;CPackConfig.cmake;CPackSourceConfig.cmake;install_manifest.txt;.*.tar.gz;Makefile*;CMakeFiles;.*.dir;.*.swp;configure.ac;.deps;.pyc;tags;configure-stamp;build-stamp;_CPack_Packages;debian/libroboint0;debian/libroboint-all;debian/libroboint-dev;debian/libroboint-diag;debian/libroboint-doc;debian/libroboint-python;")
SET(CPACK_SOURCE_PACKAGE_FILE_NAME "../libroboint-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}")
INCLUDE(CPack)

# uninstall
CONFIGURE_FILE("${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in" "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake" IMMEDIATE @ONLY)
ADD_CUSTOM_TARGET(uninstall "${CMAKE_COMMAND}" -P "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake")

# python & diag
FIND_PROGRAM(PYTHON_EXECUTABLE python)
IF (PYTHON_EXECUTABLE)
	FIND_PROGRAM(INSTALL_EXECUTABLE install)
	MESSAGE(STATUS "Found Python: " ${PYTHON_EXECUTABLE})
	# python
	IF (PYTHON_ROOT)
		ADD_CUSTOM_TARGET(python ${PYTHON_EXECUTABLE} "setup_cmake.py"
			"install" "--root" "${PYTHON_ROOT}" "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}"
			WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}/python")
	ELSE(PYTHON_ROOT)
		ADD_CUSTOM_TARGET(python ${PYTHON_EXECUTABLE} "setup_cmake.py"
			"install" "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}"
			WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}/python")
	ENDIF(PYTHON_ROOT)
	# diag
	IF (DIAG_ROOT)
		ADD_CUSTOM_TARGET(diag ${PYTHON_EXECUTABLE} "setup_cmake.py"
			"install" "--root" "${DIAG_ROOT}" "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}"
			#COMMAND "INSTALL(PROGRAMS ftdiagnose DESTINATION bin)"
			COMMAND ${INSTALL_EXECUTABLE} "-m644" ftdiagnose "${DIAG_ROOT}/${CMAKE_INSTALL_PREFIX}/bin/"
			WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}/diag" DEPENDS python)
	ELSE (DIAG_ROOT)
		ADD_CUSTOM_TARGET(diag ${PYTHON_EXECUTABLE} "setup_cmake.py"
			"install" "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}"
			#COMMAND "INSTALL(PROGRAMS ftdiagnose DESTINATION bin)"
			COMMAND ${INSTALL_EXECUTABLE} "-m644" ftdiagnose "${CMAKE_INSTALL_PREFIX}/bin/"
			WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}/diag" DEPENDS python)
	ENDIF (DIAG_ROOT)
	# install_all
	ADD_CUSTOM_TARGET(install_all DEPENDS install diag)
ELSE (PYTHON_EXECUTABLE)
	MESSAGE(STATUS "Could not find Python")
	MESSAGE(STATUS "Unable to install Python layer and diagnose utility!")
ENDIF (PYTHON_EXECUTABLE)

# documentation
FIND_PROGRAM(DOXYGEN_INSTALLED doxygen)
IF (DOXYGEN_INSTALLED)
	MESSAGE(STATUS "Found Doxygen")
	ADD_CUSTOM_TARGET(doc doxygen)
ELSE (DOXYGEN_INSTALLED)
	MESSAGE(STATUS "Could not find Doxygen")
	MESSAGE(STATUS "Unable to create documentation!")
ENDIF (DOXYGEN_INSTALLED)

ADD_DEFINITIONS(-DLIBROBOINT_VERSION_MAJOR=${CPACK_PACKAGE_VERSION_MAJOR})
ADD_DEFINITIONS(-DLIBROBOINT_VERSION_MINOR=${CPACK_PACKAGE_VERSION_MINOR})
ADD_DEFINITIONS(-DLIBROBOINT_VERSION_PATCH=${CPACK_PACKAGE_VERSION_PATCH})

add_subdirectory(lib)
add_subdirectory(examples)
add_subdirectory(src)

